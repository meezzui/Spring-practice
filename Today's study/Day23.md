#### @Transactional 어노테이션
+ `💛트랜잭션 특성💛`을 사용하기 위한 어노테이션이다.
  + `원자성` : 트랜잭션이 데이터베이스에 모두 반영되던가, 아니면 전혀 반영되지 않아야 한다.
  + `일관성` : 트랜잭션의 작업 처리 결과가 항상 일관성이 있어야 한다.
    + 트랜잭션이 진행되는 동안에 데이터베이스가 변경 되더라도 업데이트된 데이터베이스로 트랜잭션이 진행되는것이 아니라, 처음에 트랜잭션을 진행 하기 위해 참조한 데이터베이스로 진행되어야 한다.
  + `독립성` : 둘 이상의 트랜잭션이 동시에 실행되고 있을 경우, 어떤 하나의 트랜잭션이라도 다른 트랜잭션의 연산에 끼어 들수 없다.
    + 하나의 특정 트랜잭션이 완료될때까지, 다른 트랜잭션이 특정 트랜잭션의 결과를 참조할 수 없다.
  + `지속성` : 트랜잭션이 성공적으로 완료되었을 경우에 결과는 영구적으로 반영되어야 한다.
+ 즉, 일련의 작업들을 한 번에 하나의 단위로 실행하는 기능을 제공한다‼️
+ 예를 들어, 만약 쇼핑 앱을 켜서 상품을 구매하려고 한다. 그런데 내가 결제를 하는 짧은 시간 사이에 아래와 같은 일이 벌어진다면⁉️⁉️⁉️⁉️
  + 상품의 가격을 바껴버려서 잘못된 금액이 결제되는 경우
  + 같은 상품을 다른 사람도 구매해서, 상품 재고는 1개인데 2명에게 결제되는 경우
  + 결제가 완료되기 직전에 네트워크가 끊겨서, 돈은 나갔지만 구매완료는 되지 않은 경우 

  
  이러한 상황이 생기지 않게 하기 위해서는 말이지😎
  + 결제중일 때에는 해당 상품의 정보를 바꿀 수 없게 한다.
  + 결제중일 때에는 해당 상품을 다른 사람이 결제하지 못하게 한다.
  + 구매가 오류로 완료되지 않았다면, 결제된 금액을 환불 처리한다.  


  즉, 결제는 독립적으로 이루워져야 하며 결제 중엔 다른 연산이 끼어들 수 없다. 트랜잭션이 성공한 경우에만 결과를 반영하고 오류가 생긴 경우 모든 연산을 취소하고 원래 상태로 되돌린다.✌️
 
+ 보통 `Service` 패키지 안에서 사용한다.
+ `@Transactional`은 클래스나 메서드에 붙여줄 경우, 해당 범위 내 메서드가 트랜잭션이 되도록 보장해준다.

#### @Transactional은 어떤 원리로 작동할까❓❓
+ `@Transactional`이 적용되면 `Spring`은 해당 메서드에 대한 프록시를 만든다.
  + 참고📢 `프록시 패턴`: 디자인 패턴 중 하나로, 어떤 코드를 감싸면서 추가적인 연산을 수행하도록 강제하는 방법
+ 트랜잭션의 경우, 트랜잭션의 시작과 연산 종료시의 커밋 과정이 필요하므로, 프록시를 생성해 해당 메서드의 앞뒤에 트랜잭션의 시작과 끝을 추가하는 것이다.
+ 스프링 컨테이너는 트랜잭션 범위의 영속성 컨텍스트 전략을 기본으로 사용한다.
+ 즉, 서비스 클래스에서 `@Transactional`을 사용할 경우, 해당 코드 내의 메서드를 호출할 때 영속성 컨텍스트가 생긴다.
+ 영속성 컨텍스트는 트랜잭션 AOP가 트랜잭션을 시작할 때 생겨나고, 메서드가 종료되어 트랜잭션 AOP가 트랜잭션을 커밋할 경우 영속성 컨텍스트가 flush되면서 해당 내용이 반영된다. 이후 영속성 컨텍스트 역시 종료된다.
  + `AOP`란❓❓ 
    + 한방에 모든 파일을 관리를 하도록 하는 방식😉
  + `Flush`란❓❓ 
    + 영속성 컨텍스트의 변경 내용을 DB 에 반영하는 것을 말한다.
+ 이러한 방식으로 영속성 컨텍스트를 관리해 주기 때문에, `@Transactional`을 쓸 경우 트랜잭션의 원칙을 정확히 지킬 수 있다.
+ 유의사항🛑
  + 만약 같은 트랜잭션 내에서 여러 `EntityManager`를 쓰더라도, 이는 같은 영속성 컨텍스트를 사용한다.
  + 같은 `EntityManager`를 쓰더라도, 트랜잭션이 다르면 다른 영속성 컨텍스트를 사용한다.
